PRAGMA genlinepragmas

INCLUDE "DataTree.ag"

imports{
--import DataCss
import Data.List
import Data.Maybe
import FSTree
}

-- Selector's Stuff

ATTR Node Selector SSelector Property [|| nd:SELF ]
ATTR NTree [|| nd:Node ]
SEM NTree
    | NTree lhs.nd = @node.nd

ATTR NTrees NTree [ fathers: {[Node]} ||]

SEM NTree
    | NTree ntrees.fathers = @node.nd : @lhs.fathers
            loc.fathers    = @lhs.fathers

SEM Root
    | Root ntree.fathers = []

ATTR NTrees [ sbls:{[Node]} || befs:{[Node]}]
SEM NTrees
    | Cons tl.sbls  = @hd.nd : @lhs.sbls
           lhs.befs = @lhs.sbls
    | Nil  lhs.befs = @lhs.sbls

SEM NTree
    | NTree ntrees.sbls = []

-- default style sheet
{
defaultStyle :: [Selector]
defaultStyle = [ SimpSelector (TypeSelector "big")
               , CombSelector (TypeSelector "body") ">" (CombSelector (TypeSelector "p") " " (SimpSelector (TypeSelector "big")))
               , SimpSelector (TypeSelector "small")
               , SimpSelector UnivSelector
               ]
}

-- Style Sheet
ATTR NTree NTrees [|| sel:{[Maybe Selector]} ]
SEM NTree
    | NTree lhs.sel = let nsel = case @node.nd of
                                    NTag _         -> Nothing
                                    NText _        -> Nothing
                                    NStyle         -> Nothing
                                    NRuleCss (s,p) -> Just s    -- I am just needing selectors, and not his properties
                      in nsel : @ntrees.sel

SEM NTrees
    | Cons lhs.sel = @hd.sel ++ @tl.sel
    | Nil  lhs.sel = []
                      
-- Redistributing the selector's list
ATTR NTrees NTree [ css:{[Selector]} ||]
SEM Root
    | Root ntree.css = catMaybes @ntree.sel

-- Generating the Formatting Structure

SEM NTree
    | NTree loc.rlist = map (applySelector @node.nd @loc.fathers @ntrees.befs) (map (\sel -> reverse (transformSelector sel)) @lhs.css)
            loc.sel   = or @loc.rlist
            loc.num   = if @loc.sel then fromMaybe (-1) (elemIndex True @loc.rlist) + 1 else 0

ATTR NTrees [|| res:{[Maybe BoxTree]}]
SEM NTrees
    | Cons lhs.res = @hd.res : @tl.res
    | Nil  lhs.res = []

ATTR NTree [|| res: {Maybe BoxTree} ]
SEM NTree
    | NTree lhs.res = let nd = case @node.nd of
                                NTag  str  -> Just $ BoxTag  @loc.sel @loc.num str
                                NText str  -> Just $ BoxText @loc.sel @loc.num str
                                NStyle     -> Nothing
                                NRuleCss _ -> Nothing
                      in if isNothing nd
                         then Nothing
                         else Just $ BoxTree (fromJust nd) (catMaybes @ntrees.res)

ATTR Root [|| res: BoxTree ]
SEM Root
    | Root lhs.res = fromJust @ntree.res

{
data TSelector = TSimplSelector SSelector
               | TDescdSelector SSelector
               | TChildSelector SSelector
               | TSiblnSelector SSelector

transformSelector (SimpSelector s) 
    = [TSimplSelector s]
transformSelector (CombSelector s op sel)
    = case op of
        " " -> (TDescdSelector s) : transformSelector sel
        ">" -> (TChildSelector s) : transformSelector sel
        "+" -> (TSiblnSelector s) : transformSelector sel

applySelector :: Node -> [Node] -> [Node] -> [TSelector] -> Bool
applySelector    nd      fathers   siblings  []
    = True
applySelector    nd      fathers   siblings  (sel:nextSel)
    = case sel of
        TSimplSelector s -> applySimplSelector nd fathers siblings s nextSel
        TDescdSelector s -> applyDescdSelector nd fathers siblings s nextSel
        TChildSelector s -> applyChildSelector nd fathers siblings s nextSel
        TSiblnSelector s -> applySiblnSelector nd fathers siblings s nextSel

applySimplSelector nd fathers siblings s nextSel
    = if testSimpleSelector s nd
      then applySelector nd fathers siblings nextSel
      else False

applyDescdSelector nd []     siblings _ _
    = False
applyDescdSelector nd (f:fs) siblings s nextSel
    = if testSimpleSelector s f
      then if applySelector nd fs siblings nextSel
           then True
           else applyDescdSelector nd fs siblings s nextSel
      else applyDescdSelector nd fs siblings s nextSel

applyChildSelector nd []     siblings _ _
    = False
applyChildSelector nd (f:fs) siblings s nextSel
    = if testSimpleSelector s f
      then applySelector nd fs siblings nextSel
      else False

applySiblnSelector nd _ [] _ _
    = False 
applySiblnSelector nd fathers siblings s nextSel
    = let ntest = case s of
                    TypeSelector nm -> elem (NTag nm) siblings
                    UnivSelector    -> True
      in if ntest
         then applySelector nd fathers siblings nextSel
         else False

testSimpleSelector s nd = case s of
                            TypeSelector nm -> nd == (NTag nm)
                            UnivSelector    -> True
}

